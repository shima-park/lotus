package lotusctl

import (
	"os"
	"runtime"

	"github.com/shima-park/lotus/pkg/rpc/proto"
	"github.com/spf13/cobra"
)

func NewGetCmd(cmds ...*cobra.Command) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "get (RESOURCE/NAME | -p EXECUTOR_NAME)",
		Short: "Display one or many resources",
		Run: func(cmd *cobra.Command, args []string) {
			_ = cmd.Help()
		},
	}

	cmd.AddCommand(cmds...)
	return cmd
}

func NewGetExecCmd() *cobra.Command {
	var o string
	cmd := &cobra.Command{
		Use:     "executor",
		Aliases: []string{"exec"},
		Short:   "Display executor list",
		Run: func(cmd *cobra.Command, args []string) {
			c := newClient()
			list, err := c.ListExecutor()
			handleErr(err)

			var filters []proto.ExecutorView
			for _, e := range list {
				if len(args) > 0 && !stringInSlice(e.Name, args) {
					continue
				}
				filters = append(filters, e)
			}

			switch o {
			//case "term":
			//	for _, e := range filters {
			//		data, err := c.Executor.Visualize(proto.VisualizeFormatTerm, e.Name)
			//		handleErr(err)
			//		fmt.Println(string(data))
			//
			//		break // only show first pipline
			//	}
			//case "web":
			//	for _, e := range filters {
			//		data, err := c.Executor.Visualize(proto.VisualizeFormatSVG, e.Name)
			//		handleErr(err)
			//
			//		f, err := ioutil.TempFile(os.TempDir(), "*.svg")
			//		handleErr(err)
			//		defer f.Close()
			//
			//		err = ioutil.WriteFile(f.Name(), data, 0644)
			//		handleErr(err)
			//
			//		_args := browsers()
			//		err = exec.Command(_args[0], append(_args[1:], f.Name())...).Run()
			//		handleErr(err)
			//
			//		break // only show first pipline
			//	}
			//case "yaml", "yml":
			//	for _, e := range filters {
			//		fmt.Println(string(e.RawConfig))
			//	}
			default:
				var rows [][]string
				for _, e := range filters {
					rows = append(rows, []string{
						e.Name,
					})
				}

				renderTable(
					[]string{
						"name",
					},
					rows,
				)
			}

		},
	}

	cmd.Flags().StringVarP(&o, "output", "o", "", `Output format. The default output is show executor list.
-o=yaml output the executor config by yaml format.
-o=term output the executor dependency table.
-o=web output the executor monitor information to svg file and open it with system default browser`)

	return cmd
}

// browsers returns a list of commands to attempt for web visualization.
func browsers() []string {
	var cmds []string
	if userBrowser := os.Getenv("BROWSER"); userBrowser != "" {
		cmds = append(cmds, userBrowser)
	}
	switch runtime.GOOS {
	case "darwin":
		cmds = append(cmds, "/usr/bin/open")
	case "windows":
		cmds = append(cmds, "cmd /c start")
	default:
		// Commands opening browsers are prioritized over xdg-open, so browser()
		// command can be used on linux to open the .svg file generated by the -web
		// command (the .svg file includes embedded javascript so is best viewed in
		// a browser).
		cmds = append(cmds, []string{"chrome", "google-chrome", "chromium", "firefox", "sensible-browser"}...)
		if os.Getenv("DISPLAY") != "" {
			// xdg-open is only for use in a desktop environment.
			cmds = append(cmds, "xdg-open")
		}
	}
	return cmds
}

func NewGetCompCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "component",
		Aliases: []string{"comp"},
		Short:   "Display component list",
		Run: func(cmd *cobra.Command, args []string) {
			list, err := newClient().ListComponent()
			handleErr(err)

			var filters []proto.ComponentView
			for _, e := range list {
				if len(args) > 0 && !stringInSlice(e.Name, args) {
					continue
				}
				filters = append(filters, e)
			}

			var rows [][]string
			for _, e := range filters {
				rows = append(rows, []string{
					e.Name, e.SampleConfig, e.Description, e.ReflectType, e.InjectName,
				})
			}

			header := []string{
				"name", "config", "desc", "reflect_type", "inject_name",
			}

			renderTable(header, rows)
		},
	}

	return cmd
}

func NewGetProcCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "processor",
		Aliases: []string{"proc"},
		Short:   "Display processor list",
		Run: func(cmd *cobra.Command, args []string) {
			list, err := newClient().ListProcessor()
			handleErr(err)

			var filters []proto.ProcessorView
			for _, e := range list {
				if len(args) > 0 && !stringInSlice(e.Name, args) {
					continue
				}
				filters = append(filters, e)
			}

			var rows [][]string
			for _, e := range filters {
				rows = append(rows, []string{
					e.Name, e.SampleConfig, e.Description,
				})
			}

			header := []string{
				"name", "config", "desc",
			}

			renderTable(header, rows)
		},
	}

	return cmd
}

func NewGetPluginCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "plugin",
		Aliases: []string{"plug"},
		Short:   "Display plugin list",
		Run: func(cmd *cobra.Command, args []string) {
			list, err := newClient().ListPlugin()
			handleErr(err)

			var rows [][]string
			for _, e := range list {
				if len(args) > 0 && !stringInSlice(e.Path, args) {
					continue
				}
				rows = append(rows, []string{
					e.Name, e.Module, e.Path, e.OpenTime.Format("2006-01-02 15:04:05"), e.Error,
				})
			}

			header := []string{"name", "module", "path", "open_time", "error"}

			renderTable(header, rows)
		},
	}

	return cmd
}

func init() {
	rootCmd.AddCommand(
		NewGetCmd(
			NewGetExecCmd(), NewGetCompCmd(), NewGetProcCmd(), NewGetPluginCmd(),
		),
	)
}

package lotusctl

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"runtime"

	"github.com/shima-park/lotus/pkg/rpc/proto"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

func NewGetCmd(cmds ...*cobra.Command) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "get (RESOURCE/NAME | -p PIPELINE_NAME)",
		Short: "Display one or many resources",
		Run: func(cmd *cobra.Command, args []string) {
			_ = cmd.Help()
		},
	}

	cmd.AddCommand(cmds...)
	return cmd
}

func NewGetPipeCmd() *cobra.Command {
	var o string
	cmd := &cobra.Command{
		Use:     "pipeline",
		Aliases: []string{"pipe"},
		Short:   "Display pipeline list",
		Run: func(cmd *cobra.Command, args []string) {
			c := newClient()
			list, err := c.Pipeline.List()
			handleErr(err)

			var filters []proto.PipelineView
			for _, e := range list {
				if len(args) > 0 && !stringInSlice(e.Name, args) {
					continue
				}
				filters = append(filters, e)
			}

			switch o {
			case "term":
				for _, e := range filters {
					data, err := c.Pipeline.Visualize(e.Name, proto.VisualizeFormatTerm)
					handleErr(err)
					fmt.Println(string(data))

					break // only show first pipline
				}
			case "web":
				for _, e := range filters {
					data, err := c.Pipeline.Visualize(e.Name, proto.VisualizeFormatSVG)
					handleErr(err)

					f, err := ioutil.TempFile(os.TempDir(), "*.svg")
					handleErr(err)
					defer f.Close()

					err = ioutil.WriteFile(f.Name(), data, 0644)
					handleErr(err)

					_args := browsers()
					err = exec.Command(_args[0], append(_args[1:], f.Name())...).Run()
					handleErr(err)

					break // only show first pipline
				}
			case "yaml", "yml":
				for _, e := range filters {
					fmt.Println(string(e.RawConfig))
				}
			default:
				var rows [][]string
				for _, e := range filters {
					rows = append(rows, []string{e.Name, e.State, e.Schedule, fmt.Sprint(e.Bootstrap),
						e.StartTime, e.ExitTime, e.RunTimes, e.NextRunTime, e.LastStartTime, e.LastEndTime,
						e.Error,
					})
				}

				renderTable(
					[]string{
						"name", "state", "schedule", "bootstrap", "start_time", "exit_time",
						"run_times", "next_run_time", "last_start_time", "last_end_time",
						"error",
					},
					rows,
				)
			}

		},
	}

	cmd.Flags().StringVarP(&o, "output", "o", "", `Output format. The default output is show pipeline list.
-o=yaml output the pipeline config by yaml format.
-o=term output the pipeline dependency table.
-o=web output the pipeline monitor information to svg file and open it with system default browser`)

	return cmd
}

// browsers returns a list of commands to attempt for web visualization.
func browsers() []string {
	var cmds []string
	if userBrowser := os.Getenv("BROWSER"); userBrowser != "" {
		cmds = append(cmds, userBrowser)
	}
	switch runtime.GOOS {
	case "darwin":
		cmds = append(cmds, "/usr/bin/open")
	case "windows":
		cmds = append(cmds, "cmd /c start")
	default:
		// Commands opening browsers are prioritized over xdg-open, so browser()
		// command can be used on linux to open the .svg file generated by the -web
		// command (the .svg file includes embedded javascript so is best viewed in
		// a browser).
		cmds = append(cmds, []string{"chrome", "google-chrome", "chromium", "firefox", "sensible-browser"}...)
		if os.Getenv("DISPLAY") != "" {
			// xdg-open is only for use in a desktop environment.
			cmds = append(cmds, "xdg-open")
		}
	}
	return cmds
}

func NewGetCompCmd() *cobra.Command {
	var o string
	var p string
	cmd := &cobra.Command{
		Use:     "component",
		Aliases: []string{"comp"},
		Short:   "Display component list",
		Run: func(cmd *cobra.Command, args []string) {
			var list []proto.ComponentView
			if p == "" {
				var err error
				list, err = newClient().Component.List()
				handleErr(err)
			} else {
				pipe, err := newClient().Pipeline.Find(p)
				handleErr(err)
				list = pipe.Components
			}

			var filters []proto.ComponentView
			for _, e := range list {
				if len(args) > 0 && !stringInSlice(e.Name, args) {
					continue
				}
				filters = append(filters, e)
			}

			if o == "" {
				var rows [][]string
				for _, e := range filters {
					if p == "" {
						rows = append(rows, []string{
							e.Name, e.SampleConfig, e.Description, e.InjectName, e.ReflectType,
						})
					} else {
						rows = append(rows, []string{
							e.Name, e.RawConfig, e.Description, e.InjectName, e.ReflectType,
						})
					}
				}

				header := []string{
					"name", "config", "desc", "inject_name", "reflect_type",
				}

				renderTable(header, rows)
			} else {
				for _, e := range filters {
					if p == "" {
						fmt.Println(string(e.SampleConfig))
					} else {
						fmt.Println(string(e.RawConfig))
					}
				}
			}
		},
	}

	cmd.Flags().StringVarP(&p, "pipeline", "p", "", "The pipeline scope for this CLI request")
	cmd.Flags().StringVarP(&o, "output", "o", "", "Output by yaml format.")

	return cmd
}

func NewGetProcCmd() *cobra.Command {
	var o string
	var p string
	cmd := &cobra.Command{
		Use:     "processor",
		Aliases: []string{"proc"},
		Short:   "Display processor list",
		Run: func(cmd *cobra.Command, args []string) {
			var list []proto.ProcessorView
			if p == "" {
				var err error
				list, err = newClient().Processor.List()
				handleErr(err)
			} else {
				pipe, err := newClient().Pipeline.Find(p)
				handleErr(err)
				list = pipe.Processors
			}

			var filters []proto.ProcessorView
			for _, e := range list {
				if len(args) > 0 && !stringInSlice(e.Name, args) {
					continue
				}
				filters = append(filters, e)
			}

			if o == "" {
				var rows [][]string
				for _, e := range filters {
					if p == "" {
						rows = append(rows, []string{
							e.Name, e.SampleConfig, e.Description,
						})
					} else {
						rows = append(rows, []string{
							e.Name, e.RawConfig, e.Description,
						})
					}
				}

				header := []string{
					"name", "config", "desc",
				}

				renderTable(header, rows)
			} else {
				for _, e := range filters {
					if p == "" {
						fmt.Println(string(e.SampleConfig))
					} else {
						fmt.Println(string(e.RawConfig))
					}
				}
			}
		},
	}

	cmd.Flags().StringVarP(&p, "pipeline", "p", "", "The pipeline scope for this CLI request")
	cmd.Flags().StringVarP(&o, "output", "o", "", "Output by yaml format.")

	return cmd
}

func NewGetPluginCmd() *cobra.Command {
	var p string
	cmd := &cobra.Command{
		Use:     "plugin",
		Aliases: []string{"plug"},
		Short:   "Display plugin list",
		Run: func(cmd *cobra.Command, args []string) {
			list, err := newClient().Plugin.List()
			handleErr(err)

			var rows [][]string
			for _, e := range list {
				if len(args) > 0 && !stringInSlice(e.Path, args) {
					continue
				}
				rows = append(rows, []string{
					e.Name, e.Path, e.Module, e.OpenTime,
				})
			}

			header := []string{"name", "path", "module", "open_time"}

			renderTable(header, rows)
		},
	}

	cmd.Flags().StringVar(&p, "p", "", "The pipeline scope for this CLI request")

	return cmd
}

func NewGetServerCmd() *cobra.Command {
	var p string
	cmd := &cobra.Command{
		Use:     "server",
		Aliases: []string{"serv", "srv"},
		Short:   "Display server metadata",
		Run: func(cmd *cobra.Command, args []string) {
			meta, err := newClient().Server.Metadata()
			handleErr(err)

			b, err := yaml.Marshal(meta)
			handleErr(err)
			fmt.Println(string(b))
		},
	}

	cmd.Flags().StringVar(&p, "p", "", "The pipeline scope for this CLI request")

	return cmd
}

func init() {
	rootCmd.AddCommand(
		NewGetCmd(
			NewGetPipeCmd(), NewGetCompCmd(), NewGetProcCmd(), NewGetPluginCmd(),
			NewGetServerCmd(),
		),
	)
}
